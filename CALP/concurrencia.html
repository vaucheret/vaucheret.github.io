<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Conceptos Avanzados en Lenguajes de Programación</title>
<meta name="author" content="(Concurrencia)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/moon.css" id="theme"/>

<link rel="stylesheet" href="./local.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdn.jsdelivr.net/npm/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<meta name="description" content="Org-Reveal Introduction.">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Conceptos Avanzados en Lenguajes de Programación</h1><h2 class="author">Concurrencia</h2><h2 class="date">2016-10-17 lun 00:00</h2><p class="date">Created: 2022-10-18 mar 08:38</p>
</section>
<section id="table-of-contents"><div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#/slide-org5eb5f2a">Introducción</a></li>
<li><a href="#/slide-orgb6f9846">Introducción a la concurrencia a nivel de Subprograma</a></li>
<li><a href="#/slide-orgb2310ef">Los semáforos</a></li>
<li><a href="#/slide-org36cd070">monitores</a></li>
<li><a href="#/slide-org8b179b8">Pasaje de mensajes</a></li>
</ul>
</div>
</div>
</section>

<section>
<section id="slide-org5eb5f2a">
<h2 id="org5eb5f2a">Introducción</h2>
<div class="outline-text-2" id="text-org5eb5f2a">
</div>
</section>
</section>
<section>
<section id="slide-org5a686b2">
<h3 id="org5a686b2">Introducción</h3>
<ul>
<li>La concurrencia puede ocurrir en cuatro niveles:
<ul>
<li>instrucciónes de maquina</li>
<li>el de sentencias de lenguajes de alto nivel</li>
<li>unidad</li>
<li>programa</li>

</ul></li>
<li>En lenguajes de programación nos interesan a nivel sentencias del
lenguaje y unidades de programa.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5cf6279">
<h3 id="org5cf6279">Arquitecturas de Multiprocesador</h3>
<ul>
<li>Finales de los años 1950 - un procesador de propósito general y uno
o más procesadores de propósito especial para las operaciones de
entrada y salida</li>
<li>Principios de 1960 varios procesadores completos, para la
concurrencia a nivel de programa</li>
<li>A mediados de 1960 - múltiples procesadores parciales, que se
utilizan para la concurrencia a nivel de instrucción</li>
<li>Maquinas de Simple instrucción y Múltiples Datos (SIMD)</li>
<li>Maquinas de Multiple instrucciones y Múltiples Datos (MIMD)
<ul>
<li>procesadores independientes que se pueden sincronizar (a nivel de
concurrencia de unidad)</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgdd444bb">
<h3 id="orgdd444bb">Categorías de Concurrencia</h3>
<ul>
<li>Un <i>hilo de control</i> en un programa es la secuencia de los puntos
del programa alcanzados por el flujo de la ejecución del programa</li>
<li>Categorías de concurrencia:
<ul>
<li><i>concurrencia física</i> - procesadores independientes múltiples (múltiples hilos de control)</li>
<li><i>concurrencia lógica</i> - La apariencia de concurrencia física es
presentada por un procesador de tiempo compartido (software puede
ser diseñado como si hubieran múltiples hilos de control)</li>

</ul></li>
<li>Corrutinas (cuasi-concurrencia) tienen un único hilo de ejecución.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcde76b8">
<h3 id="orgcde76b8">Motivación para el estudio de la concurrencia</h3>
<ul>
<li>Implica una forma diferente de diseño de software que puede ser muy
útil, muchas situaciones del mundo real contienen concurrencia</li>
<li>Computadoras con multiprocesadores de concurrencia física son ampliamente utilizados.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb6f9846">
<h2 id="orgb6f9846">Introducción a la concurrencia a nivel de Subprograma</h2>
<div class="outline-text-2" id="text-orgb6f9846">
</div>
</section>
</section>
<section>
<section id="slide-orgb28751d">
<h3 id="orgb28751d">Introducción a la concurrencia a nivel de Subprograma</h3>
<ul>
<li>Una tarea o proceso es una unidad de programa que puede estar en ejecución concurrente con otras unidades de programa</li>
<li>Tareas difieren de subprogramas comunes, en que:
<ul>
<li>Una tarea puede iniciarse de forma implícita</li>
<li>Cuando una unidad de programa inicia la ejecución de una tarea, no
necesariamente suspende su ejecución.</li>
<li>Cuando se ha completado la ejecución de una tarea, el control
puede no volver al llamador</li>
<li>Tareas por lo general trabajan en conjunto.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6d05c37">
<h3 id="org6d05c37">Dos categorías generales de tareas</h3>
<ul>
<li><i>tareas pesadas</i> ejecutan en su propio espacio de direcciones y
tienen sus propias pilas de tiempo de ejecución.</li>
<li><i>tareas livianas</i> todas se ejecutan en el mismo espacio de
direcciones y usan la misma pila de tiempo de ejecución.</li>
<li>Una tarea es <i>disjunta</i> si no se comunica ni afecta a la ejecución
de cualquier otra tarea en el programa de ningún modo.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org8798134">
<h3 id="org8798134">Sincronización de Tareas</h3>
<ul>
<li>Un mecanismo que controla el orden en que las tareas se ejecutan</li>
<li>Dos tipos de sincronización
<ul>
<li>sincronización de cooperación</li>
<li>sincronización de competencia</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgcbde3f3">
<h3 id="orgcbde3f3">Clases de sincronización</h3>
<ul>
<li><b>Cooperación:</b> La tarea A debe esperar a que la tarea B termine
alguna actividad específica antes de poder continuar su
ejecución, por ejemplo, el problema del productor-consumidor</li>
<li><b>Competencia:</b> dos o más tareas deben utilizar algún recurso que no
se pueden utilizar simultáneamente, por ejemplo, un contador
compartido
<ul>
<li>La competencia se suele realizar mediante el acceso mutuamente excluyente.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf87e2fe">
<h3 id="orgf87e2fe">Necesidad de Sincronización de Competición</h3>

<div id="orga4cbadf" class="figure">
<p><img src="competsincr.png" alt="competsincr.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgeadd738">
<h3 id="orgeadd738">Planificador</h3>
<ul>
<li>Proporcionar sincronización requiere un mecanismo para retrasar la
ejecución de tareas</li>
<li>el control de ejecución de tareas se mantiene mediante un programa
llamado <i>planificador</i> (scheduler), que asigna la ejecución de
tareas a los procesadores disponibles.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org309e8ec">
<h3 id="org309e8ec">Estados de Ejecución de las Tareas</h3>
<ul>
<li><b>Nueva</b> - creada, pero aún no se ha inicializada</li>
<li><b>Ejecutable</b> o <b>lista</b> - lista para funcionar, pero no se está ejecutando actualmente (sin procesador disponible)</li>
<li><b>Ejecutando</b></li>
<li><b>Bloqueada</b> - ha estado funcionando, pero ahora no puede continuar (por lo general a la espera de que se produzca algún evento)</li>
<li><b>Muerta</b> - no más activa en ningún sentido.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3cadcdf">
<h3 id="org3cadcdf">Estados de Ejecución de las Tareas</h3>

<div id="org26c4379" class="figure">
<p><img src="estadostareas.png" alt="estadostareas.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org68247ea">
<h3 id="org68247ea">Liveness y Deadlock</h3>
<ul>
<li><i>Liveness</i> es una característica que una unidad de programa puede o
puede  no tener</li>
<li>En código secuencial, significa que la unidad finalmente completará su ejecución.</li>
<li>En un entorno concurrente, una tarea puede perder fácilmente su <i>liveness</i></li>
<li>Si todas las tareas en un entorno concurrente pierden su <i>liveness</i>,
se denomina <i>deadlock</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-org60ffdfc">
<h3 id="org60ffdfc">Métodos de proveer sincronización</h3>
<ul>
<li>Semáforos</li>
<li>Monitores</li>
<li>Pasaje de Mensajes</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb2310ef">
<h2 id="orgb2310ef">Los semáforos</h2>
<div class="outline-text-2" id="text-orgb2310ef">
</div>
</section>
</section>
<section>
<section id="slide-org8578563">
<h3 id="org8578563">Los semáforos</h3>
<ul>
<li>Dijkstra - 1965</li>
<li>Un semáforo es una estructura de datos que consta de un contador y una cola para almacenar descriptores de tareas.</li>
<li>Los semáforos se pueden utilizar para implementar guardas en el
código que accede a estructuras de datos compartidos</li>
<li>Los semáforos tienen sólo dos operaciones, esperar y liberar (originalmente llamado P y V por Dijkstra)</li>
<li>Los semáforos se pueden utilizar para proporcionar tanto
sincronización de competencia y de cooperación.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orga9b2ebb">
<h3 id="orga9b2ebb">Sincronización de Cooperación con semáforos</h3>
<ul>
<li>Ejemplo: Un buffer compartido</li>
<li>El buffer se implementa como un Tipo de Dato Abstracto con las
operaciones <i>DEPOSIT</i> y <i>FETCH</i> como las únicas formas de acceder al
buffer.</li>
<li>Se usan dos semáforos de cooperación: <i>emptyspots</i> y <i>fullspots</i></li>
<li>Los contadores de semáforos se utilizan para almacenar el número de
espacios vacíos y espacios cargados en el buffer.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5c61f77">
<h3 id="org5c61f77">Sincronización de Cooperación con semáforos</h3>
<ul>
<li><i>DEPOSIT</i> debe comprobar primero <i>emptyspots</i> para ver si hay espacio en el buffer</li>
<li>Si hay espacio, el contador de <i>emptyspots</i> disminuye y el valor es insertado</li>
<li>Si no hay espacio, la tarea se almacena en la cola de <i>emptyspots</i></li>
<li>Cuando <i>DEPOSIT</i> termina,  debe incrementar el contador de <i>fullspots</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-org7bb5ec9">
<h3 id="org7bb5ec9">Sincronización de Cooperación con semáforos</h3>
<ul>
<li><i>FETCH</i> debe comprobar <i>fullspots</i> para ver si hay un valor.
<ul>
<li>Si hay un spot completo, el contador de <i>fullspots</i> se decrementa y se elimina el valor.</li>
<li>Si no hay valores en el buffer, la tarea debe ser colocado en la cola de <i>fullspots</i>.</li>
<li>cuando <i>FETCH</i> termina, incrementa el contador de <i>emptyspots</i>.</li>

</ul></li>
<li>Las operaciones de <i>FETCH</i> y <i>DEPOSIT</i> en los semáforos se llevan a
cabo a través de dos operaciones del semáforo llamadas <i>wait</i> y
<i>release</i>.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org4feeae7">
<h3 id="org4feeae7">Semaforo: operación <i>wait</i></h3>
<div class="org-src-container">

<pre  class="src src-pascal"><code trim>wait(aSemaphore)
<span style="color: #00ffff;">if</span> aSemaphore&#8217;s counter &gt; 0 <span style="color: #00ffff;">then</span> 
   decrement aSemaphore&#8217;s counter
<span style="color: #00ffff;">else</span> 
   put the caller <span style="color: #00ffff;">in</span> aSemaphore&#8217;s queue
   attempt <span style="color: #00ffff;">to</span> transfer control <span style="color: #00ffff;">to</span> a ready task 
     -- <span style="color: #00ffff;">if</span> the task ready queue is empty, 
     -- deadlock occurs 
<span style="color: #00ffff;">end</span>
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org8c8f38e">
<h3 id="org8c8f38e">Semáforos: Operación <i>Release</i></h3>
<div class="org-src-container">

<pre  class="src src-pascal"><code trim>release(aSemaphore)
<span style="color: #00ffff;">if</span> aSemaphore&#8217;s queue is empty <span style="color: #00ffff;">then</span>
   increment aSemaphore&#8217;s counter
<span style="color: #00ffff;">else</span>
   put the calling task <span style="color: #00ffff;">in</span> the task ready queue
   transfer control <span style="color: #00ffff;">to</span> a task from aSemaphore&#8217;s queue
<span style="color: #00ffff;">end</span>
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org880dbb8">
<h3 id="org880dbb8">Codigo Productor/Consumidor</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>semaphore fullspots, emptyspots;
fullstops.count = 0;
emptyspots.count = BUFLEN;
task producer;
	loop
	-- produce VALUE –-
	wait (emptyspots); {wait for space}
	DEPOSIT(VALUE);
	release(fullspots); {increase filled}
	end loop;
end producer;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org96f5f80">
<h3 id="org96f5f80">Código Productor/Consumidor</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task consumer;
	loop
	wait (fullspots);{wait till not empty}}
	FETCH(VALUE);
	release(emptyspots); {increase empty}
	-- consume VALUE –-
	end loop;
end consumer;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orga20b040">
<h3 id="orga20b040">Sincronización de Competición con Semáforos</h3>
<ul>
<li>Un tercer semáforo, llamado <i>acces</i>, se utiliza para controlar el
acceso (sincronización de competencia)
<ul>
<li>El contador de <i>acces</i> sólo tendrá los valores 0 y 1</li>
<li>Tal semáforo se llama un <i>semáforo binario</i></li>

</ul></li>
<li>Tener en cuenta que <i>wait</i> y <i>release</i> debe ser atómicos.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge9e73b6">
<h3 id="orge9e73b6">Código Productor/Consumidor</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>semaphore access, fullspots, emptyspots;
access.count = 0;
fullstops.count = 0;
emptyspots.count = BUFLEN;
task producer;
	loop
	-- produce VALUE –-
	wait(emptyspots); {wait for space}
	wait(access);     {wait for access)
	DEPOSIT(VALUE);
	release(access); {relinquish access}
	release(fullspots); {increase filled}
	end loop;
end producer;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org695193f">
<h3 id="org695193f">Código Productor/Consumidor</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task consumer;
	loop
	wait(fullspots);{wait till not empty}
	wait(access);   {wait for access}
	FETCH(VALUE);
	release(access); {relinquish access}
	release(emptyspots); {increase empty}
	-- consume VALUE –-
	end loop;
end consumer;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orge0a07a1">
<h3 id="orge0a07a1">Evaluación de Semáforos</h3>
<ul>
<li>El mal uso de los semáforos puede provocar fallos en la
sincronización de la cooperación, por ejemplo, el buffer tendrá
overflow si el <i>wait</i> de <i>fullspots</i> falla.</li>
<li>El mal uso de los semáforos puede provocar fallos en la
sincronización de la competencia, por ejemplo, el programa entrara
en <i>Deadlock</i> si el <i>release</i> de <i>access</i> falla.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org36cd070">
<h2 id="org36cd070">monitores</h2>
<div class="outline-text-2" id="text-org36cd070">
</div>
</section>
</section>
<section>
<section id="slide-orgaa5e63e">
<h3 id="orgaa5e63e">monitores</h3>
<ul>
<li><b>Pascal</b> concurrente, <b>Modula</b>, <b>Mesa</b>, <b>Ada</b>, <b>Java</b>, <b>C#</b></li>
<li>La idea: encapsular los datos compartidos y sus operaciones para restringir el acceso</li>
<li>Un monitor es un tipo abstracto de datos para los datos compartidos</li>

</ul>

</section>
</section>
<section>
<section id="slide-org8fca0fb">
<h3 id="org8fca0fb">Sincronización de Competición</h3>
<ul>
<li>Los datos compartidos son residentes en el monitor (en lugar de en las unidades de cliente)</li>
<li>Todo acceso reside en el monitor
<ul>
<li>el monitor garantiza la sincronización al permitir un solo acceso a la vez</li>
<li>Las llamadas a procedimientos del monitor se ponen en cola de
forma implícita si el monitor está ocupado en el momento de la
llamada.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org0f620e5">
<h3 id="org0f620e5">Sincronización de Cooperación</h3>
<ul>
<li>Cooperación entre procesos es todavía una tarea de programación
<ul>
<li>El programador debe garantizar que un buffer compartido no
experimenta overflow o underflow</li>

</ul></li>

</ul>


<div id="org1c6a22b" class="figure">
<p><img src="monitor.png" alt="monitor.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgbc389e6">
<h3 id="orgbc389e6">Evaluación de Monitores</h3>
<ul>
<li>Es un mejor modo de proporcionar la sincronización de la competencia que los semáforos.</li>
<li>Los semáforos se pueden utilizar para implementar monitores</li>
<li>Los monitores pueden ser utilizados para implementar semáforos</li>
<li>Soporte para la sincronización de cooperación es muy similar al de
los semáforos, por lo que tiene los mismos problemas</li>

</ul>

</section>
</section>
<section>
<section id="slide-org8b179b8">
<h2 id="org8b179b8">Pasaje de mensajes</h2>
<div class="outline-text-2" id="text-org8b179b8">
</div>
</section>
</section>
<section>
<section id="slide-org5be6a2f">
<h3 id="org5be6a2f">Pasaje de mensajes</h3>
<ul>
<li>El paso de mensajes es un modelo general para la concurrencia
<ul>
<li>Puede modelar tanto los semáforos como los monitores</li>
<li>No es sólo para la sincronización de la competencia</li>

</ul></li>
<li>Idea central: la comunicación de tareas es como ver a un médico, la
mayoría de las veces te espera o lo esperas, pero cuando tu y él
esten listo, te reunirás o tendras un <i>rendezvous</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgccce580">
<h3 id="orgccce580">Pasaje de mensajes <i>Rendezvous</i></h3>
<ul>
<li>Un mecanismo para permitir que una tarea indique cuándo está
dispuesta a aceptar mensajes</li>
<li>Las tareas necesitan una manera de recordar quién está esperando que
su mensaje sea aceptado y alguna forma "justa" de elegir el
siguiente mensaje</li>
<li>Cuando el mensaje de una tarea remitente es aceptado por una
tarea receptora, la transmisión de mensaje real se denomina <i>rendezvous</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-org32ce761">
<h3 id="org32ce761">Soporte de <b>Ada</b> para concurrencia</h3>
<ul>
<li>El modelo de mensajes de Ada 83
<ul>
<li>Las tareas de Ada tienen parte de especificación y cuerpo como los
paquetes; La especificación tiene la interfaz, que es la
colección de puntos de entrada:</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre  class="src src-ada"><code trim>task Task_Example is
	entry ENTRY_1 (Item : in Integer);
end Task_Example;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org800974d">
<h3 id="org800974d">Cuerpo de la Tarea</h3>
<ul>
<li>El cuerpo de la tarea describe la acción que tiene lugar cuando se
produce un <i>rendezvous</i></li>
<li>Una tarea que envía un mensaje se suspende mientras espera que el
mensaje sea aceptado y durante el <i>rendezvous</i></li>
<li>Los puntos de entrada en la especificación se describen con
cláusulas de <i>accept</i> en el cuerpo:</li>

</ul>

<div class="org-src-container">

<pre  class="src src-ada"><code trim>accept entry_name (formal parameters) do
    ...
end entry_name
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org248eae3">
<h3 id="org248eae3">Ejemplo de Cuerpo de Tarea</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task body TASK_EXAMPLE is
     begin
     loop
     accept ENTRY_1 (ITEM: in FLOAT) do
     ...
     end ENTRY_1;
     end loop;
   end TASK_EXAMPLE;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgf610f68">
<h3 id="orgf610f68">Semántica del pasaje de mensajes de <b>Ada</b></h3>
<ul>
<li>La tarea se ejecuta hasta la parte superior de la cláusula <i>accept</i> y
espera un mensaje</li>
<li>Durante la ejecución de la cláusula <i>accept</i>, el remitente suspende
su ejecución</li>
<li>Los parámetors del <i>accept</i> pueden transmitir información en una o
ambas direcciones</li>
<li>Cada cláusula <i>accept</i> tiene una cola asociada para almacenar
mensajes en espera.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org35841e4">
<h3 id="org35841e4">Líneas de tiempo del <i>Rendevous</i></h3>

<div id="org74b7261" class="figure">
<p><img src="rendevous.png" alt="rendevous.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org6fe4ef3">
<h3 id="org6fe4ef3">Servidor y actor</h3>
<ul>
<li>Una tarea que tiene cláusulas <i>accept</i>, pero ningún otro código
se llama una tarea servidor</li>
<li>Una tarea sin cláusulas <i>accept</i> se denomina tarea actor
<ul>
<li>Una tarea de actor puede enviar mensajes a otras tareas</li>
<li>Nota: Un remitente debe conocer el nombre de entrada del receptor, pero no viceversa (asimétrico)</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org509c619">
<h3 id="org509c619">Representación Gráfica del <i>Rendezvous</i></h3>

<div id="orgddd7546" class="figure">
<p><img src="rendevous2.png" alt="rendevous2.png" /> 
</p>
</div>

</section>
</section>
<section>
<section id="slide-orgffa1a3c">
<h3 id="orgffa1a3c">Ejemplo de tarea <i>Actor</i></h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task WATER_MONITOR; -- specification
task body WATER_MONITOR is -- body
begin
  loop
  if WATER_LEVEL &gt; MAX_LEVEL
    then SOUND_ALARM;
  end if;
  delay 1.0; -- No further execution
	    -- for at least 1 second
  end loop;
end WATER_MONITOR;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgdc42e30">
<h3 id="orgdc42e30">Múltiples puntos de entrada</h3>
<ul>
<li>Las tareas pueden tener más de un punto de entrada
<ul>
<li>La especificación de la tarea tiene una cláusula de entrada para
cada una.</li>
<li>El cuerpo de la tarea tiene una cláusula de <i>accept</i> para cada
cláusula de entrada, colocada en una cláusula de <i>select</i>, que
está en un bucle.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org937fcf3">
<h3 id="org937fcf3">Una tarea con múltiples entradas</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task body TASK_EXAMPLE is
      loop
	select 
	  accept ENTRY_1 (formal params) do
	  ...
	  end ENTRY_1;
	  ...
	or
	  accept ENTRY_2 (formal params) do
	  ...
	  end ENTRY_2;
	  ...
	end select;
      end loop;
    end TASK_EXAMPLE;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org7d04f69">
<h3 id="org7d04f69">Semántica de tareas con multiples clausulas select</h3>
<ul>
<li>Si exactamente una cola de entrada no esta vacía, elija un mensaje de ella</li>
<li>Si más de una cola de entrada no esta vacía, elije una, de forma no determinística, para aceptar un mensaje</li>
<li>Si todos están vacíos, espera</li>
<li>La construcción se llama a menudo una <i>espera selectiva</i></li>
<li>Cláusula <i>accept</i> extendida - código que sigue a la cláusula, pero antes de la siguiente cláusula
<ul>
<li>Ejecutado simultáneamente con la tarea remitente</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-orgd763d3e">
<h3 id="orgd763d3e">Sincronización de Cooperación con Pasaje de Mensajes</h3>
<ul>
<li>Provisto por cláusulas <i>accept</i> con guardas:</li>

</ul>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>when not FULL(BUFFER) =&gt;
    accept DEPOSIT(NEW_VALUE) do
</code></pre>
</div>
<ul>
<li>Una cláusula <i>accept</i> con una cláusula <i>when</i> es abierta o cerrada
<ul>
<li>Una cláusula cuya guarda es verdadera se llama <i>abierta</i></li>
<li>una cláusula cuya guarda es falsa se llama <i>cerrada</i></li>
<li>una cláusula sin guarda es siempre abierta.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org1db26f6">
<h3 id="org1db26f6">Semántica del <i>select</i> con cláusulas <i>accept</i> con guardas</h3>
<ul>
<li><i>select</i> primero verifica las guardas de todas las cláusulas</li>
<li>Si exactamente una está abierta, se comprueba la cola de mensajes</li>
<li>Si más de uno está abierto, no deterministicamente se elige una cola
entre ellas para comprobar los mensajes.</li>
<li>Si todos están cerrados, es un error de tiempo de ejecución</li>
<li>Una cláusula <i>select</i> puede incluir una cláusula <i>else</i> para evitar el error
<ul>
<li>Cuando se completa la cláusula <i>else</i>, el bucle se repite</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org6440485">
<h3 id="org6440485">Ejemplo de Tarea con clausulas <i>accept</i> con guardas</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task GAS_STATION_ATTENDANT is
	entry SERVICE_ISLAND (CAR : CAR_TYPE);
	entry GARAGE (CAR : CAR_TYPE);
	end GAS_STATION_ATTENDANT;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgf02acfa">
<h3 id="orgf02acfa">Ejemplo de Tarea con clausulas <i>accept</i> con guardas</h3>
<div class="org-src-container">

<pre  class="src src-ada"><code trim>task body GAS_STATION_ATTENDANT is
  begin
    loop
      select
	when GAS_AVAILABLE =&gt;
		   accept SERVICE_ISLAND (CAR : CAR_TYPE) do
		 FILL_WITH_GAS (CAR);
	       end SERVICE_ISLAND;
      or
	     when GARAGE_AVAILABLE =&gt;
	       accept GARAGE (CAR : CAR_TYPE) do
		 FIX (CAR);
	       end GARAGE;
      else
	     SLEEP;
      end select;
    end loop;
  end GAS_STATION_ATTENDANT;
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org1ca37b1">
<h3 id="org1ca37b1">Sincronización de Competición con Pasaje de Mensajes</h3>
<ul>
<li>Modela el acceso mutuamente exclusivo a los datos compartidos</li>
<li>Ejemplo: un búfer compartido</li>
<li>Encapsula el búfer y sus operaciones en una tarea</li>
<li>La sincronización de la competencia está implícita en la semántica de las cláusulas <i>accept</i>
<ul>
<li>Sólo una cláusula <i>accept</i> en una tarea puede estar activa en un momento dado.</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org87d42eb">
<h3 id="org87d42eb">Concurrencia en Ada 95</h3>
<ul>
<li>Ada 95 incluye las características de Ada 83 para la concurrencia, además
de dos nuevas características:
<ul>
<li>Objetos protegidos: una forma más eficiente de implementar datos
compartidos para permitir el acceso a una estructura de datos
compartida que se puede hacer sin <i>rendezvous</i></li>
<li>Comunicación asincrónica</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org718ea2b">
<h3 id="org718ea2b">Objetos Protegidos de Ada 95</h3>
<ul>
<li>Un objeto protegido es similar a un tipo de dato abstracto</li>
<li>El acceso a un objeto protegido es a través de mensajes pasados a
las entradas, como con una tarea, o a través de subprogramas protegidos</li>
<li>Un procedimiento protegido proporciona acceso de lectura y escritura mutuamente exclusivo a objetos protegidos</li>
<li>Una función protegida proporciona acceso concurrente de sólo lectura
a objetos protegidos.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org79d67c8">
<h3 id="org79d67c8">Evaluación de <b>Ada</b></h3>
<ul>
<li>El modelo de concurrencia de pasaje de mensajes es potente y general.</li>
<li>Los objetos protegidos son una mejor manera de proporcionar datos compartidos sincronizados</li>
<li>En ausencia de procesadores distribuidos, la elección entre
monitores y tareas con el paso de mensajes es algo una cuestión de
gusto</li>
<li>Para sistemas distribuidos, el paso de mensajes es un mejor modelo para la concurrencia.</li>

</ul>
</section>
</section>
</div>
</div>
<p> Created by yjwen. </p>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
width:1200, height:800, margin: 0.1, minScale:0.2, maxScale:2.5, transition:'cube',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
