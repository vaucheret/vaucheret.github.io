<!DOCTYPE html>
<html><head><title>Semanticas</title>
<link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css"><link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/night.css"><link rel="stylesheet" href="grids.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdn.jsdelivr.net/npm/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/default.min.css">
<script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body><div class="reveal" ><div class="slides" ><section id="sec-title-slide" ><h1 class="title" >Semanticas</h1>
<h2 class="author" >C. A. L. P.</h2>
<h3 class="date" >Claudio Vaucheret</h3>
</section>
<section><h2>Introducción</h2>
<div class="outline-text-2" ></div>
</section>
<section><h3>Introducción</h3>
<ul><li class="fragment appear"><span style="color:blue;"><b>Sintaxis:</b>
</span>La forma y estructura de las expresiones, sentencias y unidades del programa.</li>
<li class="fragment appear"><span style="color:green;"><b>Semántica:</b>
</span>El significado de las expresiones, sentencias, y unidades del programa.</li>
<li class="fragment appear">Sintaxis y Semántica proveen una Definición del Lenguaje<ul><li class="fragment appear">Usuarios de una Definición del Lenguaje<ul><li class="fragment appear">Otros diseñadores del Lenguaje</li>
<li class="fragment appear">Implementadores</li>
<li class="fragment appear">Programadores</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section><h3>Definición Formal de Lenguajes</h3>
<div style="font-size: 85%;">
<ul><li class="fragment appear"><span style="color:blue;"><b>Reconocedores</b>
</span><ul><li>Un dispositivo de reconocimiento que lee cadenas del lenguaje y decide si las cadenas de entrada pertenecen al Lenguaje.</li>
<li>Ejemplo, el analizador sintáctico de un compilador.</li>
</ul>
</li>
<li class="fragment appear"><span style="color:green;"><b>Generadores</b>
</span><ul><li>Un dispositivo que genera sentencias de un lenguaje</li>
<li>Se puede determinar si la sintaxis de una sentencia particular                                 es correcta comparándola con la estructura del generador.</li>
</ul>
</li>
</ul>
</section>
<section><h3><span style="color:red;">Métodos Formales de Describir la Sintaxis</span></h3>
<ul><li class="fragment appear"><span style="color:green;">Forma Backus-Naur y gramáticas libres de contexto</span><ul><li class="fragment appear">El método mas conocido para describir la sintaxis de un Lenguaje                                  de Programación.</li>
</ul>
</li>
<li class="fragment appear"><span style="color:green;">BNF Extendida</span><ul><li class="fragment appear">Mejora la legibilidad de BNF.</li>
</ul>
</li>
<li class="fragment appear"><span style="color:green;">Gramáticas y Reconocedores</span></li>
</ul>
</section>
<section><h3><span style="color:red;">BNF y Gramáticas Libres de Contexto</span></h3>
<div style="font-size: 90%;">
<ul><li class="fragment appear"><span style="color:green;">Gramáticas libres de Contexto</span><ul><li class="fragment appear">Desarrollado por Noam Chomsky a mediados de 1950s</li>
<li class="fragment appear">Generadores de Lenguajes, medio de  describir la la sintaxis de lenguajes naturales</li>
<li class="fragment appear">Define clases de lenguajes</li>
</ul>
</li>
<li class="fragment appear"><span style="color:green;">Forma Backus-Naur (1959)</span><ul><li class="fragment appear">Inventado por John Backus para describir Algol 58</li>
<li class="fragment appear">Árboles sintacticos - ambiguedad del lenguaje</li>
</ul>
</li>
</ul>
</section>
<section><h2>Semántica Estática</h2>
<div class="outline-text-2" ></div>
</section>
<section><h3>Gramáticas con atributos</h3>
<ul><li class="fragment appear"><span style="color:orange;">Las Gramáticas Libres de Contexto (GLC) no pueden describir toda la sintaxis de los lenguajes de programación.</span></li>
<li class="fragment appear"><span style="color:brown;">Agregados a GLC para introducir información semántica en los árboles sintácticos</span></li>
<li class="fragment appear"><span style="color:yellow;">Principal aporte de las Gramáticas con atributos</span><ul><li><span style="color:yellow;">Especificación de la semántica estática</span></li>
<li><span style="color:yellow;">Diseño de Compiladores (chequeo de semántica estática)</span></li>
</ul>
</li>
</ul>
</section>
<section><h3><span style="color:red;">Gramáticas con atributos: Definición</span></h3>
<div style="font-size: 80%;">
<ul><li>Una Gramática con atributos es una gramática libre de contexto \(G =  (S,N,T,P)\) con los siguientes agregados:<ul><li class="fragment highlight-current-red">Por cada símbolo de gramática \(x\) hay un conjunto \(A(x)\) de valores de atributos</li>
<li class="fragment highlight-current-red">Cada regla tiene un conjunto de funciones que definen ciertos atributos de los no terminales en la regla</li>
<li class="fragment highlight-current-red">Cada regla tiene un conjunto posiblemente vacío de predicados para chequear la consistencia de los atributos</li>
</ul>
</li>
</ul>
</section>
<section><h3><span style="color:green;">Gramáticas con atributos: Definición</span></h3>
<div style="font-size: 90%;">
<ul><li class="fragment highlight-current-green">Sea \(X_0 \to X_1 ... X_n\) una regla de la gramática libre de contexto</li>
<li class="fragment highlight-current-green">Funciones de la forma \(S(X_0) = f(A(X_1), ... , A(X_n))\) definen <span style="color:yellow;"><em>atributos sintetizados</em>
</span></li>
<li class="fragment highlight-current-green">Funciones de la forma \(I(X_j) = f(A(X_0)), ... , f(A(X_{j-1}))\) para \(i <= j <= n\), definen <span style="color:yellow;"><em>atributos heredados</em>
</span></li>
<li class="fragment highlight-current-green">Inicialmente hay <span style="color:yellow;"><em>atributos intrínsecos</em>
</span> en las hojas de los árboles sintácticos</li>
</ul>
</section>
<section><h3>Gramáticas con atributos: Un Ejemplo</h3>
<div style="font-size: 65%;">
<ul><li>Sintaxis<ul><li>\( \mbox{&lt;assign&gt;} \to \mbox{&lt;var&gt;} = \mbox{&lt;expr&gt;}\)</li>
<li>\( \mbox{&lt;expr&gt;} \to \mbox{&lt;var&gt;} + \mbox{&lt;var&gt;} | \mbox{&lt;var&gt;} \)</li>
<li>\( \mbox{&lt;var&gt;} \to A | B | C \)</li>
</ul>
</li>
<li>tipo-real: sintetizado por \(\mbox{&lt;var&gt;}\) y \(\mbox{&lt;expr&gt;}\)</li>
<li>tipo-esperado: heredado por \(\mbox{&lt;expr&gt;}\)</li>
</ul>
<div class="figure">
<p><img src=attribgram1.png  width=auto  height=auto</p>
</div>
</section>
<section><h3>Gramáticas con atributos: Un Ejemplo</h3>
<div style="font-size: 65%;">
<ol><li>Regla sintáctica: \( \mbox{&lt;assign&gt;} \to \mbox{&lt;var&gt;} = \mbox{&lt;expr&gt;} \)<ul><li>Regla semántica: \( \mbox{&lt;expr&gt;.tipo-esperado} \leftarrow \mbox{&lt;var&gt;.tipo-real} \)</li>
</ul>
</li>
<li>Regla sintáctica: \( \mbox{&lt;expr&gt;} \to \mbox{&lt;var&gt;[2]} + \mbox{&lt;var&gt;[3]} \)<ul><li>Regla semántica: \( \mbox{&lt;expr&gt;.tipo-real} \leftarrow \)<p>if \( \mbox{&lt;var&gt;[2].tipo-real} = int \)  and \( \mbox{&lt;var&gt;[3].tipo-real} = int \)  then \( int \) else \( real \)  end if  </p>
</li>
<li>Predicado: \( \mbox{&lt;expr&gt;.tipo-real} = \mbox{&lt;expr&gt;.tipo-esperado } \)</li>
</ul>
</li>
<li>Regla sintáctica: \( \mbox{&lt;expr&gt;} \to \mbox{&lt;var&gt;} \)<ul><li>Regla semántica: \( \mbox{&lt;expr&gt;.tipo-real } \leftarrow \mbox{&lt;var&gt;.tipo-real } \)</li>
<li>Predicado: \( \mbox{&lt;expr&gt;.tipo-real } = \mbox{&lt;expr&gt;.tipo-esperado } \)</li>
</ul>
</li>
<li>Regla sintáctica: \( \mbox{&lt;var&gt;} \to A | B | C \)<ul><li>Regla semántica: \( \mbox{&lt;var&gt;.tipo-real } \leftarrow \) lookup \( ( \mbox{&lt;var&gt;.string}) \)</li>
</ul>
</li>
</ol>
</section>
<section><h3>Gramáticas con atributos</h3>
<div style="font-size: 65%;">
<p><span style="color:red;">¿Cómo se computan los valores de atributos?</span></p>
<ul><li>Si todos los atributos fueran heredados, el árbol podría ser completado en un orden <em>top-down</em>
</li>
<li>Si todos los atributos fueran sintetizados, el árbol podría ser completado en un orden <em>bottom-up</em>
</li>
<li>En muchos casos, ambos casos de atributos son utilizados y se necesita una combinación de ambos órdenes.</li>
</ul>
<div class="figure">
<p><img src=attribgram2.png  width=auto  height=auto</p>
</div>
</section>
<section><h3>Gramáticas con atributos</h3>
<div style="font-size: 65%;">
<ol><li>\( \mbox{&lt;var&gt;.tipo-real } \leftarrow look-up(A) \)  (Regla 4)</li>
<li>\( \mbox{&lt;expr&gt;.tipo-esperado } \leftarrow \mbox{&lt;var&gt;.tipo-real } \) (Regla 1)</li>
<li><ul><li>\(  \mbox{&lt;var&gt;[2].tipo-real }\leftarrow look-up(A) \) (Regla 4)</li>
<li>\(  \mbox{&lt;var&gt;[3].tipo-real }\leftarrow look-up(B) \) (Regla 4)</li>
</ul>
</li>
<li>\( \mbox{&lt;expr&gt;.tipo-real }\leftarrow \) int o real  (Regla 2)</li>
<li>\( \mbox{&lt;expr&gt;.tipo-esperado } = \mbox{&lt;expr&gt;.tipo-real } \) es VERDADERO o FALSO (Regla 2)</li>
</ol>
<div class="figure">
<p><img src=attribgram3.png  width=auto  height=auto</p>
</div>
</section>
<section><h2>Semántica Dinámica</h2>
<div class="outline-text-2" ></div>
</section>
<section><h3>Métodos Desarrollados</h3>
<div style="font-size: 90%;">
<ul><li><b><span style="color:green;">Semántica Operacional</span></b>
<ul><li class="fragment appear">Operaciones en una máquina abstracta</li>
</ul>
</li>
<li><b><span style="color:green;">Semántica Denotacional</span></b>
<ul><li class="fragment appear">Usa funciones para especificar la semántica, los programas se convierten en funciones para poder aplicar la teoría de funciones recursivas</li>
</ul>
</li>
<li><b><span style="color:green;">Semántica Axiomática</span></b>
<ul><li class="fragment appear">Aplica la lógica formal: afirmaciones (aserciones) para describir suposiciones y resultados deseados</li>
<li class="fragment appear">Los axiomas o reglas de inferencia son usados en cada tipo de sentencias.</li>
</ul>
</li>
</ul>
</section>
<section><h3><span style="color:green;">Semántica Operacional</span></h3>
<section><h3></h3>
<div style="font-size: 90%;">
<p>Describe el significado de un programa ejecutando sus sentencias sobre una máquina, simulada o real. Los cambios en el estado de la máquina (registros, memoria, etc) define el significado de la sentencia.</p>
<p>Para el uso de una semántica operacional en un lenguaje de alto nivel se necesita una máquina virtual</p>
<ul><li>Un intérprete de hardware puro podría ser muy costoso.</li>
<li>Un intérprete de software puro también tiene problemas (dependiente de la máquina )</li>
</ul>
</section>
<section><h3></h3>
<p>Una mejor alternativa: Una simulación completa de la computadora</p>
<ul><li>Construir un traductor del codigo fuente a un codigo maquina de una computadora idealizada</li>
<li>Construir un simulador para la computadora idealizada</li>
</ul>
</section>
<section><h3><span style="color:green;">Semántica Operacional</span></h3>
<ul><li>Simulador de Prolog en Prolog<pre><code>
mi(true).
mi((A,B)) :-
        mi(A),
        mi(B).
mi(Goal) :-
        Goal \= true,
        Goal \= (_,_),
        clause(Goal, Body),
        mi(Body).
</code></pre>
</li>
<li>Evaluación:<ul><li>Bueno usado informalmente.</li>
<li>Extremadamente complejo usado formalmente.</li>
</ul>
</li>
</ul>
</section>
</section>
<section><h3></h3>
<section><h3><span style="color:green;">Semántica Denotacional</span></h3>
<div style="font-size: 85%;">
<ul><li class="fragment highlight-current-green">Basado en la teoría de funciones recursivas</li>
<li class="fragment highlight-current-green">El método de descripción semántica mas abstracto</li>
<li class="fragment highlight-current-green">Originalmente desarrollado por Scott y Strachey (1970)</li>
<li class="fragment highlight-current-green">El proceso de construir una especificación denotacional para un lenguaje es definir un objeto matemático por cada entidad del Lenguaje<ul><li>Define una función que relaciona instancias de las entidades del lenguaje con instancias de los objetos matemáticos correspondientes</li>
</ul>
</li>
<li class="fragment highlight-current-green">El significado de las construcciones del lenguaje son definidos solo por los valores de las variables del programa</li>
</ul>
</section>
<section><h3><span style="color:green;">Semántica Denotacional vs Semántica Operacional</span></h3>
<div style="font-size: 85%;">
<ul><li class="fragment highlight-current-green">En la semántica operacional los cambios de estado son definidos por algoritmos codificados</li>
<li class="fragment highlight-current-green">En la semántica denotacional los cambios de estado son definidos por funciones matemáticas rigurosas.</li>
<li class="fragment highlight-current-green">El estado de un programa son los valores de todas las variables actuales  \(s = { < i_1,v_1 >,< i_2,v_2 >, ... ,< i_n,v_n > }\)</li>
<li class="fragment highlight-current-green">Sea \(VARMAP\), una función que, cuando recibe un nombre de variable y un estado retorna el valor actual de esa variable \(VARMAP(i_j, s) = v_j\)</li>
</ul>
</section>
<section><h3><span style="color:red;">Números Decimales</span></h3>
<ul><li>\( \mbox{&lt;dec-num&gt;} \to 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | \)</li>
<li>\( M_{dec} ('0') = 0,  M_{dec} ('1') = 1, ... , M_{dec} ('9') = 9 \)</li>
<li>\( M_{dec} ( \mbox{&lt;dec-num&gt;} '0') = 10 * M_{dec} ( \mbox{&lt;dec-num&gt;} ) \)</li>
<li>\( M_{dec} ( \mbox{&lt;dec-num&gt;} '1') = 10 * M_{dec} ( \mbox{&lt;dec-num&gt;} ) + 1 \)</li>
<li>\(\ldots\)</li>
<li>\( M_{dec} ( \mbox{&lt;dec-num&gt;} '9') = 10 * M_{dec} ( \mbox{&lt;dec-num&gt;} ) + 9 \)</li>
</ul>
</section>
<section><h3><span style="color:blue;">Expresiones</span></h3>
<p>relaciona expresiones a \(Z \cup \{ error \} \)</p>
<p>suponiendo que las expresiones son números decimales, variables, o expresiones binarias teniendo un operador aritmético y dos operandos, cada uno de los cuales puede ser una expresión.</p>
</section>
<section><h3></h3>
<div style="font-size: 60%;">
<ol><li>\( M_e ( \mbox{&lt;expr&gt;}, s) = case \mbox{&lt;expr&gt;} of \)</li>
<li>\(\qquad \mbox{&lt;dec-num&gt;} \to M_{dec} ( \mbox{&lt;dec-num&gt;} , s)\)</li>
<li>\(\qquad \mbox{&lt;var&gt;} \to \mbox{ if } VARMAP(\mbox{&lt;var&gt;}, s)\)</li>
<li>\(\qquad \mbox{&lt;binary-expr&gt;} \to \)</li>
<li>\(\qquad \qquad \mbox{ if } (M_e(\mbox{&lt;binary-expr&gt;} . \mbox{&lt;left-expr&gt;} , s) = undef\)</li>
<li>\(\qquad \qquad \qquad \mbox{ OR } M_e(\mbox{&lt;binary-expr&gt;} . \mbox{&lt;right-expr&gt;} , s) = undef)\)</li>
<li>\(\qquad \qquad \mbox{ then error}\)</li>
<li>\(\qquad \qquad \mbox{ else}\)</li>
<li>\(\qquad \qquad \qquad \mbox{ if } (\mbox{&lt;binary-expr&gt;}.\mbox{&lt;operator&gt;} = ‘+’ then \)</li>
<li>\(\qquad \qquad \qquad  M_e(\mbox{&lt;binary-expr&gt;}.\mbox{&lt;left-expr&gt;}, s) + M_e(\mbox{&lt;binary-expr&gt;}.\mbox{&lt;right-expr&gt;}, s)\)</li>
<li>\(\qquad \qquad \qquad \mbox{ else }\)</li>
<li>\(\qquad \qquad \qquad M_e(\mbox{&lt;binary-expr&gt;}.\mbox{&lt;left-expr&gt;}, s) * M_e(\mbox{&lt;binary-expr&gt;}.\mbox{&lt;right-expr&gt;}, s)\)</li>
<li>\( \ldots \)</li>
</ol>
</section>
<section><h3><span style="color:brown;">asignación</span></h3>
<div style="font-size: 85%;">
<ol><li>\( M_a ( X := E, s) = \)</li>
<li>\(\qquad \mbox{if } M_e(E, s) = error \)</li>
<li>\(\qquad \qquad \mbox{ then error}\)</li>
<li>\(\qquad \qquad \mbox{ else } s' = { < i_{1}',v_{1}' >, < i_{2}',v_{2}' >, \ldots , < i_{n}',v_{n}' >},\)</li>
<li>\(\qquad \qquad \qquad \mbox{ where for } j = 1, 2, \ldots n,\)</li>
<li>\(\qquad \qquad \qquad \qquad v_{j}' = varmap(i_j, s) \mbox{ if } i_j <> x \)</li>
<li>\(\qquad \qquad \qquad \qquad \qquad  = M_e(E, s) \mbox{ if } i_j = x\)</li>
</ol>
</section>
<section><h3><span style="color:yellow;">Ciclo 'while'</span></h3>
<div style="font-size: 85%;">
<ol><li>\( M_l(\mbox{while B do L}, s) =\)</li>
<li>\(\qquad \mbox{ if } M_b(B, s) = undef\)</li>
<li>\(\qquad \qquad \mbox{ then error}\)</li>
<li>\(\qquad \qquad \mbox{ else if } M_b(B, s) = false\)</li>
<li>\(\qquad \qquad \qquad \mbox{ then } s\)</li>
<li>\(\qquad \qquad \qquad \mbox{ else if } M_{sl}(L, s) = error\)</li>
<li>\(\qquad \qquad \qquad \qquad \mbox{ then error}\)</li>
<li>\(\qquad \qquad \qquad \qquad \mbox{ else } M_l(\mbox{while B do L}, M_{sl}(L, s))\)</li>
</ol>
</section>
<section><h3>Ciclo</h3>
<ul><li class="fragment highlight-current-red">El significado del ciclo es el valor de las variables del programa después de que las sentencias del ciclo han sido ejecutadas el número prescrito de veces, asumiendo que no ha habido errores</li>
<li class="fragment highlight-current-red">En esencia el ciclo ha sido convertido de iterativo a recursivo, donde el control recursivo es definido por otra función recursiva de estados</li>
<li class="fragment highlight-current-red">La recursión comparada con la iteración es mas facil de describir con rigor matemático</li>
</ul>
</section>
<section><h3><span style="color:green;">Evaluación</span></h3>
<ul><li class="fragment highlight-current-green">Puede ser usado para probar la corrección de programas</li>
<li class="fragment highlight-current-green">Provee un modo riguroso de pensar los programas</li>
<li class="fragment highlight-current-green">Puede ser una ayuda al diseño de lenguajes</li>
<li class="fragment highlight-current-green">Ha sido usado en sistemas de generación de compiladores</li>
<li class="fragment highlight-current-green">A causa de su complejidad es de poco uso para los usuarios del lenguaje</li>
</ul>
</section>
</section>
<section><h3></h3>
<section><h3>Semántica Axiomática</h3>
<ul><li class="fragment fade-in-then-semi-out">Basado en Lógica Formal (cálculo de predicados)</li>
<li class="fragment fade-in-then-semi-out">Propósito original: Verificación formal de programas</li>
<li class="fragment fade-in-then-semi-out">Axiomas o reglas de inferencia son definidas para cada tipo de sentencia del lenguaje (para permitir transformaciones de expresiones a otras expresiones)</li>
<li class="fragment fade-in-then-semi-out">Las expresiones son llamadas <em>aserciones</em>
 (afirmaciones) </li>
</ul>
</section>
<section><h3><span style="color:blue;">Semántica Axiomática</span></h3>
<ul><li class="fragment highlight-current-blue">Una aserción antes de una sentencia (una <em>precondición</em>
establece las relaciones y restricciones entre variables que son verdaderas en ese punto de la ejecución</li>
<li class="fragment highlight-current-blue">Una aserción que sigue a una sentencia es una <em>postcondición</em>
</li>
<li class="fragment highlight-current-blue">Una <em>precondición mas débil</em>
 es la menos restrictiva precondición que garantiza la postcondición</li>
</ul>
</section>
<section><h3><span style="color:red;">Semántica Axiomática</span></h3>
<ul><li class="fragment appear">La Forma es \({P}\) sentencia \({Q}\)</li>
<li class="fragment appear">Un ejemplo<ul><li class="fragment appear">\(a = b + 1 \: \{a > 1\} \)</li>
<li class="fragment appear">una posible precondición: \( \{b > 10\} \)</li>
<li class="fragment appear"><em>precondición mas débil</em>
\( \{b > 0\} \)</li>
</ul>
</li>
</ul>
</section>
<section><h3><span style="color:brown;">Proceso de prueba de programa</span></h3>
<p>La postcondición para el programa entero es el resultado deseado</p>
<ul><li class="fragment appear">Se trabaja hacia atrás a través del programa hasta la primer sentencia. Si la precondición sobre la primer sentencias está inferida por la especificación de entrada del programa, entonces el programa es correcto.</li>
</ul>
</section>
<section><h3>Axiomas</h3>
<ul><li class="fragment appear">Un axioma para la asignación<ul><li>( x = E ): \( \{Q_{x \to E}\} \ x = E \ \{Q\} \)</li>
</ul>
</li>
<li class="fragment appear">La regla de la Consecuencia<ul><li> \[ \frac{ \{P\} \ S \ \{Q\}, P' \Rightarrow P, Q \Rightarrow Q'}{\{P'\} \ S \ \{Q'\}} \] </li>
</ul>
</li>
</ul>
</section>
<section><h3>Axiomas</h3>
<ul><li class="fragment appear">\( x = 2 * y - 3 \{x > 25 \}  \)</li>
<li class="fragment appear">\( 2 * y - 3 > 25  \)</li>
<li class="fragment appear">\( y > 14  \)</li>
<li class="fragment appear">\( x = x + y - 3 \{x > 10 \}  \)</li>
<li class="fragment appear">\( x + y - 3 > 10  \)</li>
<li class="fragment appear">\( y > 13 - x  \)</li>
</ul>
</section>
<section><h3>Axiomas</h3>
<div style="font-size: 80%;">
 \[ \frac{ \{x > 3\} \ x = x - 3 \ \{x > 0\}, (x > 5) \Rightarrow (x > 3), (x > 0) \Rightarrow (x > 0)}{\{x > 5\} \ x = x - 3 \ \{x > 0\}} \]</section>
<section><h3>Axiomas</h3>
<ul><li>Una regla de inferencia para secuencias<ul><li>\( \{P1\} S1 \{P2\} \)</li>
<li>\( \{P2\} S2 \{P3\} \)</li>
</ul>
</li>
</ul>
\[ \frac{ \{P1\} \ S1 \ \{P2\}, \{P2\} \ S2 \ \{P3\}}{\{P1\} \ S1;S2 \ \{P3\}} \]</section>
<section><h3>Axiomas</h3>
<ul><li>\( y = 3 * x + 1  \);</li>
<li>\( x =  y + 3 \);</li>
<li>\(\{ x < 10 \}  \)</li>
</ul>
<p>La precondición para la segunda asignación es \( y < 7 \) la cual es usada como postcondición para la primer sentencia. La precondición para la primera asignación puede ser computada</p>
<ul><li>\( 3 * x + 1 < 7  \)</li>
<li>\( x < 2 \)</li>
</ul>
</section>
<section><h3>Axiomas</h3>
<p>regla de inferencia para sentencias de selección <em>if</em>
</p>
<p>{P} <b>if</b>
 B <b>then</b>
 S1 <b>else</b>
 S2 {Q}</p>
\[ \frac{ \{B \ and \ P \} \ S1 \ \{Q\}, \{(not B) \ and \ P\} \ S2 \ \{Q\}}{\{P\} \ if \ B \ then \ S1 \ else \ S2 \ \{Q\}}\]</section>
<section><h3><span style="color:magenta;">Ejemplo</span></h3>
<b>if</b>
 \( x > 0 \) <b>then</b>
 \( y = y -1 \) <b>else</b>
 \( y = Y + 1 \)<ul><li class="fragment appear">con la postcondición \( \{ y > 0 \} \)</li>
<li class="fragment appear">el axioma de asignación para la clausula <b>then</b>
 : \( y = y - 1  \{ y > 0 \} \)  produce \( \{ y - 1 > 0 \} \) o \( \{ y > 1 \} \)</li>
<li class="fragment appear">el axioma de asignación para la clausula <b>else</b>
 : \( y = y + 1  \{ y > 0 \} \)  produce \( \{ y + 1 > 0 \} \) o \( \{ y > -1 \} \)</li>
<li class="fragment appear">Como \( \{ y > 1 \} \Rightarrow \{ y > -1 \}\) la regla de consecuencia nos permite usar \( \{ y > 1 \} \) como precondición del total de la sentencia</li>
</ul>
</section>
<section><h3>Axiomas</h3>
<p>Una regla de inferencia para un ciclo <em>while</em>
</p>
<p>{P} <b>while</b>
 B <b>do</b>
 S <b>end</b>
 {Q}</p>
\[ \frac{ (I \ and \ B ) S \{I\} }{\{I\} \ while \ B \ do \ S \{I \ and (not B)\}} \]donde \(I\) es el <em>invariante</em>
 (la hipótesis inductiva)</section>
<section><h3>Axiomas</h3>
<p>Características del <em>invariante</em>
: \(I\) debe satisfacer las siguientes condiciones:</p>
<ol><li>\( P \Rightarrow I \) el invariante debe ser inicialmente verdadero</li>
<li>\( \{I\} \ B \ \{I\}  \) la evaluación de la parte booleana no debe cambiar la validez de \(I\)</li>
<li>\( \{I \ and \ B \} \ S \ \{I\}  \) \(I\) no cambia por la ejecución del cuerpo del ciclo  iterativo</li>
<li>\( (I \ and \ (not \ B)) \Rightarrow Q \) si \(I\) es verdadero y \(B\) es falso es implicado \(Q\)</li>
<li>El ciclo termina</li>
</ol>
</section>
<section><h3><span style="color:magenta;">Ejemplo</span></h3>
<div style="font-size: 65%;">
<p><b>while</b>
 \( y <> x \) <b>do</b>
 \( y = Y + 1 \) <b>end</b>
 \( \{ y = x \} \)</p>
<ul><li class="fragment appear">Para cero iteraciones la precondición mas débil es \( \{ y = x \} \)</li>
<li class="fragment appear">Para una iteración es: \[ wp( y = y + 1, \{y = x\}) = \{ y + 1 = x \} = \{ y = x - 1 \} \]</li>
<li class="fragment appear">Para dos iteraciones es:\[ wp( y = y + 1, \{y = x - 1\}) = \{ y + 1 = x - 1\} = \{ y = x - 2 \} \]</li>
<li class="fragment appear">Para tres iteraciones es:\[ wp( y = y + 1, \{y = x - 2\}) = \{ y + 1 = x - 2\} = \{ y = x - 3 \} \]</li>
<li class="fragment appear">Es obvio que \(\{y <  x \} \)es suficiente para los casos de uno o mas iteraciones. Combinado con \(\{y = x \} \)para el caso base obtenemos  \( \{y <= x \}\), que puede ser el invariante del ciclo.</li>
</ul>
</section>
<section><h3><span style="color:magenta;">Ejemplo</span></h3>
<div style="font-size: 75%;">
<ul><li>\( P \Rightarrow I \) \( \{y <= x \} \Rightarrow \{y <= x \} \) </li>
<li>\( \{I\} \ B \ \{I\}  \)  \( \{y <= x \} \ \{y <> x \}  \ \{y <= x\}  \) </li>
<li>\( \{I \ and \ B \} \ S \ \{I\}  \) \( \{y <= x \ and \ y <> x \} \ y = y + 1 \ \{y <= x\}  \) aplicando el axioma de asignación a \( y = y + 1 \{ y <= x \} \) tenemos \( \{y + 1 <= x \}\) que es equivalente a \( \{y < x \}\) el cual es implicado por \( \{y < x \ and \ y <> x\}\).</li>
<li>\( (I \ and \ (not \ B)) \Rightarrow Q \) \( \{(y <= x) \ and \ (not \ y <> x)\} \Rightarrow \{y = x\} \) sigue \( \{(y <= x) \ and \ (y = x)\} \Rightarrow \{y = x\} \) sigue \( \{y = x \} \Rightarrow \{y = x\} \)</li>
<li>El ciclo termina</li>
</ul>
</section>
<section><h3><span style="color:purple;">Invariante</span></h3>
<ul><li>El invariante es la versión mas debil de la postcondición del ciclo, y es también una precondición.</li>
<li>Debe ser lo suficientemente debil para satisfacer a priori el comienzo del ciclo, pero cuando se combina con la condición de salida debe ser los suficientemente fuerte para forzar la verdad de la postcondición</li>
</ul>
</section>
<section><h3><span style="color:purple;">Evaluación</span></h3>
<ul><li>Desarrollar axiomas y reglas de inferencia para todas las sentencias en un lenguaje es dificultoso</li>
<li>Es una buena herramienta para la verificación de programas y un excelente marco para razonar los programas, pero no es útil para los usuarios del lenguaje y desarrolladores de compiladores</li>
</ul>
</section>
</section>
</div>
</div>
<script src="https://unpkg.com/reveal.js/dist/reveal.js" ></script>
<script>Reveal.initialize({      transition: 'slide'});</script>
</body>
</html>
